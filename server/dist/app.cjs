import{createRequire as e}from"node:module";const s=require("bcrypt"),a=e(import.meta.url)("node:fs"),t=e(import.meta.url)("node:path"),r=e(import.meta.url)("node:url"),n=e(import.meta.url)("node:crypto"),o=(require("nanoid"),require("jsonwebtoken")),i=()=>o,c=(0,t.dirname)((0,r.fileURLToPath)("file:///C:/Users/steve/Documents/backend_full/src/helpers/auth.helper.js")),l={hashPassword:async e=>{const a=await s.genSalt(10);return{hashedPassword:await s.hash(e,a),salt:a}},comparePassword:async(e,a)=>await s.compare(e,a),generateToken:async(e={email:"",name:""})=>i().sign({email:e.email,name:e.name},process.env.SECRET_TOKEN_KEY,{expiresIn:"1h"}),authenticateToken(e,s){const a=e.cookies.authcookie;if(null==a)return s.sendStatus(401);jwt.verify(a,process.env.SECRET_TOKEN_KEY,((a,t)=>{if(a)return s.sendStatus(403);e.user=t,next()}))},generateKeyPair(){const e=`${c}/id_rsa_public.pem`,s=`${c}/id_rsa_private.pem`;if(a.existsSync(e)||a.existsSync(s))console.log("Las claves ya existen. No se generaron nuevos archivos.");else{const t=n.generateKeyPairSync("rsa",{modulusLength:4096,publicKeyEncoding:{type:"pkcs1",format:"pem"},privateKeyEncoding:{type:"pkcs1",format:"pem"}});a.writeFileSync(e,t.publicKey),a.writeFileSync(s,t.privateKey),a.chmodSync(e,292),a.chmodSync(s,256),console.log("Claves generadas y guardadas correctamente.")}}},u=(require("dotenv/config"),require("express")),d=require("cors"),m=require("morgan"),g=require("cookie-parser"),p=()=>({getGreetings:(e,s)=>{s.status(200).send({message:"Hello, World!"})}}),y=(0,u.Router)(),h=p();y.get("/hello",h.getGreetings);const w=y,S=require("http-status-codes"),E=require("@seald-io/nedb"),b=(0,r.fileURLToPath)("file:///C:/Users/steve/Documents/backend_full/src/db/index.js"),f=t.dirname(b),v=()=>{const e=t.resolve(f,"../db/collections");var s;s=e,a.existsSync(s)||a.mkdirSync(s,{recursive:!0});const r=t.join(e,"user_store.db"),n=t.join(e,"auth_store.db"),o=e=>new Promise(((s,a)=>{e.loadDatabase((e=>{e?a(e):s()}))})),i=new E({filename:r}),c=new E({filename:n});return(async()=>{try{await o(i),await o(c),console.log("Databases loaded successfully.")}catch(e){console.error("Error loading databases:",e)}})(),{userCollection:i,authCollection:c}},O=e=>({success:!!e._id,data:e}),C=()=>{const{userCollection:e}=v();return{create:async s=>{if(!s)throw new Error("User is required");const a=await e.insertAsync(s);return O(a)},getAll:()=>{const s=e.getAllData();return O(s)},getById:async s=>{if(!s)throw new Error("Id is required");const a=await e.findOneAsync({_id:s});return console.log(a),O(a)}}},_=()=>{const e=C();return{index:async(e,s)=>{s.status(S.StatusCodes.OK).send({message:"Hello, World!"})},create:async(s,a)=>{const t=s.body,r=await e.create(t);a.status(S.StatusCodes.OK).send({message:"User created",response:r})},getAll:async(s,a)=>{const t=e.getAll();a.status(S.StatusCodes.OK).send(t)},getById:async(s,a)=>{const{id:t}=s.params,r=await e.getById(t);console.log("hey ==>",r),a.status(S.StatusCodes.OK).send(r)}}},q=(0,u.Router)(),A=_();q.post("/",A.index),q.post("/create",A.create),q.get("/getAll",A.getAll),q.get("/getById/:id",A.getById);const T=q,K=()=>{const{userCollection:e,authCollection:s}=v();return{login:(e={email:"",password:""})=>{console.log(e)},register:async(a={name:"",lastname:"",email:"",password:""})=>{const t=await l.hashPassword(a.password),r=e.insertAsync({name:a.name,lastname:a.lastname,email:a.email}),n=s.insertAsync({email:a.email,password:t.hashedPassword,salt:t.salt,active:!0});return await Promise.all([r,n])},logout:()=>{},forgotPassword:()=>{},resetPassword:()=>{},changePassword:()=>{},verifyEmail:async a=>{const t=await e.findOneAsync({email:a}),r=await s.findOneAsync({email:a});return t&&r?{message:"FOUND",isFound:!0,data:{auth:r,user:t}}:{message:"NOT_FOUND",isFound:!1,data:r}},resendEmailVerification:()=>{}}},N=(0,t.dirname)((0,r.fileURLToPath)("file:///C:/Users/steve/Documents/backend_full/src/services/auth.service.js")),P=(0,t.join)(N,".."),U=()=>{const e=K();return{login:async(s,a)=>{const{email:t,password:r}=s.body,n=await e.verifyEmail(t);if(!n.isFound)return a.status(S.StatusCodes.NOT_FOUND).send({message:"USER_NOT_FOUND",data:[]});if(!await l.comparePassword(r,n.data.auth.password))return a.status(S.StatusCodes.UNAUTHORIZED).send({message:"INVALID_PASSWORD",data:[]});const o=await l.generateToken({email:n.data.email,name:n.data.name});return a.cookie("authcookie",o,{maxAge:9e5,httpOnly:!0,secure:!0,sameSite:"strict"}).status(S.StatusCodes.OK).send({message:"LOGIN_SUCCESS",data:n.data.user})},register:async(s,a)=>{const{name:t,lastname:r,email:n,password:o}=s.body;if((await e.verifyEmail(n)).isFound)return a.status(S.StatusCodes.BAD_REQUEST).send({message:"USER_EXIST",data:[]});const i=await e.register({name:t,lastname:r,email:n,password:o});return a.status(S.StatusCodes.OK).send({message:"USER_CREATED",data:i})},getPublicKey:async(e,s)=>{const t=`${P}/helpers/id_rsa_public.pem`,r=a.readFileSync(t,"utf8");return s.status(S.StatusCodes.OK).send({publicKey:r})},validateAuthCookies:async(e,s)=>s.status(S.StatusCodes.OK).send({message:"VALID_TOKEN",autorized:!0,content:[]}),logout:async(e,s)=>s.clearCookie("authcookie").status(S.StatusCodes.OK).send({message:"LOGOUT_SUCCESS",data:[]})}},k=require("yup"),R=()=>({create:k.object().shape({name:k.string().matches(/^[a-zA-Z'-\s]*$/,"Name can only contain letters, spaces, hyphens, and apostrophes").min(2,"Name must be at least 2 characters long").max(15,"Name must be less than or equal to 15 characters long").required("Name is required"),lastname:k.string().matches(/^[a-zA-Z'-\s]*$/,"Lastname can only contain letters, spaces, hyphens, and apostrophes").min(2,"Lastname must be at least 2 characters long").max(15,"Lastname must be less than or equal to 15 characters long").required("Lastname is required"),email:k.string().email("Must be a valid email").required("Email is required"),password:k.string().matches(/^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$/,"Password must be at least 8 characters long, include an uppercase letter, a lowercase letter, a number, and a special character").required("Password is required")}),login:k.object().shape({email:k.string().email("Must be a valid email").required("Email is required"),password:k.string().matches(/^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$/,"Password must be at least 8 characters long, include an uppercase letter, a lowercase letter, a number, and a special character").required("Password is required")})}),D=e=>async(s,a,t)=>{const{body:r}=s;try{await e.validate(r,{abortEarly:!1}),t()}catch(e){if(e instanceof k.ValidationError){const s=e.inner.map((e=>({key:e.path,message:e.message})));return a.status(400).json({errors:s})}return a.status(500).json({message:"Internal Server Error"})}},I=async(e,s,a)=>{const t=e.cookies.authcookie;if(!t)return s.status(S.StatusCodes.UNAUTHORIZED).send({message:"NO_TOKEN_PROVIDED",content:[]});if(!i().verify(t,process.env.SECRET_TOKEN_KEY))return s.status(S.StatusCodes.UNAUTHORIZED).send({message:"INVALID_TOKEN",content:[]});a()},x=(0,u.Router)(),j=U(),L=R();x.post("/register",D(L.create),j.register),x.post("/login",D(L.login),j.login),x.post("/logout",j.logout),x.get("/protected",I,j.validateAuthCookies),x.get("/public_key",I,j.getPublicKey);const F=x,$=require("helmet"),Z=(e,s,a)=>{if(e.headers["content-length"]&&Number.parseInt(e.headers["content-length"])>1048576)return s.status(413).json({error:"Payload size exceeds the limit"});a()};process.env.TZ="America/Costa_Rica";const z=Number.parseInt(process.env.PORT)||3002,B=u();B.use(d({origin:"http://localhost:5173",credentials:!0})),B.use(m("dev")),B.use($()),B.use(u.json()),B.use(((e,s,a)=>{e.setTimeout(5e3),s.setTimeout(5e3),a()})),B.use(g()),B.use(u.urlencoded({extended:!0})),B.disable("x-powered-by"),B.use(Z),B.use("/greetings",w),B.use("/user",T),B.use("/auth",F),B.use(((e,s,a,t)=>{console.error(e.stack),a.status(500).send("Something went wrong!")}));const V=()=>{B.listen(z,(()=>{console.log(`Server started on port http://localhost:${z}`)}))},H=()=>{V(),l.generateKeyPair(),console.log("Server started")};(async()=>{H()})();